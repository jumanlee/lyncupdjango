## LyncUp

**LyncUp** is a web app that uses machine learning to intelligently match remote workers into small-group chatrooms. It is designed to reduce social isolation among remote workers and foster meaningful, professional connections.

When users feel ready to network, they simply join a queue. LyncUp then finds the best possible match from other users currently in the queue, placing them into a chatroom with 2–3 people who are predicted, based on past interactions and preferences, to align well with one another. 

As users continue to participate and privately “Like” those they enjoyed interacting with, the system refines its understanding of their preferences. Over time, this enables increasingly accurate and relevant matches, helping users build deeper, more valuable professional networks.

## Frontend Repository 
https://github.com/jumanlee/lyncupreact

## Software Architecture

![Architecture Diagram](readme_images/architecture.png)

As shown in the architecture diagram, LyncUp’s software architecture uses
Django as the backend, React as the frontend, Redis with Django Channels to handle real-
time features such as queuing and chatroom functionalities. Django Rest Framework (DRF)
is used to provide endpoints for user registration, login, recording “Like” data and
friendship management. User information are stored in a PostgresSQL database and is
accessed via Django’s Object Relational Model (ORM). 

On the frontend side, React
manages the user interface by displaying the appropriate interfaces for queuing, liking users
and chatrooms once users are matched. Users who enter the “Queue” are placed in Redis by
the QueueConsumer, which listens for WebSocket connections and tracks who is waiting in
the queue. 

As scheduled by Celery Beat, Celery Workers run the matching algorithm by first
retrieving the list of waiting users from Redis. The matching algorithm then uses an ANN
index file generated by another ANN-generating algorithm with the use of Node2Vec
embeddings of user “Like” data. Specifically, all users are nodes and all “Like” interactions
are considered directed edges in a graph and Node2Vec learns an embedding that captures
each user’s similarity to others based on their interactions.


The ANN file allows the matching process to efficiently look up the top-k nearest
neighbours for each waiting user. The system also enables multiple queue “clusters”,
however, currently we only use a single cluster called “global” and a fallback “leftover”
queue for random matching if required. This is because we currently do not have enough
users in the system to support multi-cluster matching. Doing so would affect the matching
quality.

Once the matching algorithm successfully identifies groups of three or four users, it assigns
each group a unique room ID. The room IDs are then broadcast via WebSocket back to
each user’s React app, which prompts the frontend to close the existing queue WebSocket,
then opens a new WebSocket to the assigned chatroom and then navigates the users to their
respective chatrooms.
The real-time chatroom functionality is managed by GroupConsumer. 

The process from
queuing to real-time matching to chatroom redirection all depends on the choreography
between Django Channels (WebSockets management), Redis (for both queue storage and
channel layers), Celery (to schedule and perform the matching tasks) and the Node2Vec-
based representations that enables the matching algorithm.

