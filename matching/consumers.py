import json 
import jwt
from users.models import AppUser
from django.conf import settings
from channels.db import database_sync_to_async
from channels.generic.websocket import AsyncWebsocketConsumer
import redis.asyncio as redis
from urllib.parse import parse_qs
from .tasks import run_matching_algo

class QueueConsumer(AsyncWebsocketConsumer):
    async def connect(self):
        print("entered connect method")

        #assign queue name

        self.queue = "queue"

        #connect to the Redis

        self.redis = redis.from_url(settings.REDIS_URL, decode_responses=True)
        query_string = self.scope.get("query_string", b"").decode("utf-8")
        print(f"Query string: {query_string}") 



        query_params = parse_qs(query_string)
        # query_params will be:
        # {
        #     "token": ["abc123"],
        # }
        token = query_params.get("token", [None])[0]

        if token:

            #get user
            try:
                user = await self.get_token_user(token)

                if not user:
                    print("Invalid user")
                    await self.close(code=4123)
                    return


                #By setting self.scope["user"] = user, we are linking the authenticated user to this WebSocket connection. This makes it easy to access the user information later in the code for this connection. 
                #self.scope is a buiklt in property of AsyncWebsocketConsumer
                self.scope["user"] = user
                #save the first name and last name of the user to scope
                self.scope["firstname"] = user.firstname
                self.scope["lastname"] = user.lastname

                #saved in Redis for user matching
                await self.redis.sadd(
                    self.queue,
                    self.scope["user_id"],   
                )


                await self.channel_layer.group_add(
                    #the layer group name will be the user's id, for easy identifying and procesing in task.py
                    f'user_queue_{self.scope["user_id"]}',
                    self.channel_name 
                    #channel_name is automatically generated by Django Channels for each WebSocket connection
                    #this is like: take this specific WebSocket connection (self.channel_name) and add it to the group (self.groupname).
                )

                await self.accept()

            except Exception as error:
                print(error)
                await self.close(code=4123)

        else:
            print("No token provided, closing connection")
            await self.close(code=4123)
            return

        print("run_matching_algo.delay()")    

        run_matching_algo.delay()


    async def disconnect(self, disconnect_code):

        try:

            await self.channel_layer.group_discard(
                f'user_queue_{self.scope["user_id"]}',
                self.channel_name
            )


            if await self.redis.exists(self.queue):
                await self.redis.srem(self.queue, self.scope["user_id"])

            #check what's left in Redis
            membersSet = await self.redis.smembers(self.queue)
            print("whats left in Redis queue:")
            print(membersSet)

            # #if no one is left in the group, we must delete the groupname from Redis user tracking
            # if not membersSet:
            #     await self.redis.delete(self.groupname)



            #must close redis for this consumer instance
            if self.redis:
                await self.redis.aclose()

        except Exception as error:
            print(error)

    


    async def send_room_id(self, event):
        room_id = event.get('room_id')

        if room_id:
            await self.send(text_data=json.dumps({
                'room_id': room_id
            }))
            print(f"Sent room assignment to user {self.scope['user_id']}.")
        else:
            print("Incomplete event data received in send_room_id.")



    #the decorator converts sychronouse function to asynchronous, more suitable for websocket.
    @database_sync_to_async
    def get_token_user(self, token):

        print("entered get_token_user method")

        try:

            data = jwt.decode(token, settings.SECRET_KEY, algorithms=["HS256"])
            print(data)

            self.scope["user_id"] = data['user_id']

            return AppUser.objects.get(id=data['user_id'])

        except jwt.ExpiredSignatureError:
            print("Token has expired")
            return None
        except Exception as error:
            print(error)
            return None