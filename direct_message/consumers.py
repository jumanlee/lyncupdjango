from channels.generic.websocket import AsyncWebsocketConsumer
import json
from .models import Conversation, DirectMessage
from django.utils.timezone import now
from asgiref.sync import sync_to_async
from channels.db import database_sync_to_async

@sync_to_async
def is_participant(conversation_id, user):
    return Conversation.objects.filter(id=conversation_id, participants=user).exists()

class DirectMessageConsumer(AsyncWebsocketConsumer):
    #conversation_id from url route
    async def connect(self):
        #conversation_id from url route
        self.conversation_id = self.scope['url_route']['kwargs']['conversation_id']
        self.room_group_name = f"chat_{self.conversation_id}"

        user = self.scope["user"]
        allowed = await is_participant(self.conversation_id, user)
        if not allowed:
            await self.send(text_data=json.dumps({
                "error": "Access denied. You are not a participant in this conversation."
            }))
            await self.close()
            return

        await self.channel_layer.group_add(
            self.room_group_name,
            self.channel_name
        )
        await self.accept()

    async def disconnect(self, disconnect_code):
        await self.channel_layer.group_discard(
            self.room_group_name,
            self.channel_name
        )
        #channel_name is automatically generated by Django Channels for each WebSocket connection
        #self.channel_name is assigned automatically by Django Channels when your consumer is instantiated, before connect() is called.

    async def receive(self, text_data):
        data = json.loads(text_data)
        message = data['message']
        conversation_id = data['conversation_id']
        user = self.scope["user"]  #authenticated user 

        #save to databse just like a REST view
        conversation = await database_sync_to_async(Conversation.objects.get)(id=conversation_id)
        new_msg = await database_sync_to_async(DirectMessage.objects.create)(
            conversation=conversation,
            sender=user,
            content=message,
            timestamp=now()
        )

        #broadcast the message to all participants
        await self.channel_layer.group_send(
            self.room_group_name,
            {
                "type": "chat_message",
                "message": message,
                "sender": user.username,
                "timestamp": str(new_msg.timestamp)
            }
        )

    async def chat_message(self, event):
        #send message to Websocket client
        await self.send(text_data=json.dumps({
            "message": event["message"],
            "sender": event["sender"],
            "timestamp": event["timestamp"]
        }))
